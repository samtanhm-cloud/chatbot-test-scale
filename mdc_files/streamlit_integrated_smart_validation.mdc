---
name: Streamlit Email Link Validator (Browser-Based)
description: Full email link validation using Playwright MCP - extracts and validates ALL links
version: 2.0.0 - Full Validation
author: AI Assistant
note: |
  This is a Streamlit-compatible version of integrated_smart_validation.mdc
  Uses pure Playwright MCP commands (browser fetch API) for validation
  
  ‚úÖ FEATURES:
  - Extracts ALL visible email links (deduplicated)
  - Validates EVERY link with HTTP requests
  - Detects accessible vs broken links
  - Measures response time for each link
  - Returns complete JSON report with results
  - Works in Streamlit Cloud (no bash dependencies)
  
  ‚ö†Ô∏è LIMITATIONS vs CLI version:
  - CORS may block some cross-origin requests (security)
  - No AI language detection (no GPT calls)
  - No CSV export (JSON output only)
  - No localization checking (/en/ vs /ja/)
  - Slower than curl (browser-based)
  
  üìä OUTPUT:
  - Per-link: URL, anchor text, status, duration, errors
  - Summary: Total links, accessible count, error count, avg duration
---

## USAGE

Provide the Draftr asset ID as a variable:
- Variable name: `asset_id`
- Example value: `3927289`
- Prompt: "Validate email links for asset 3927289"
- The automation will extract and validate all links automatically

---

## PHASE 1: Navigate to Email and Extract Links

### Step 1.1: Navigate to Draftr email preview
```mcp
{
  "tool": "playwright_navigate",
  "params": {
    "url": "https://webpub.autodesk.com/draftr/asset/{{asset_id}}?v=preview"
  }
}
```

### Step 1.2: Wait for page load
```mcp
{
  "tool": "playwright_evaluate",
  "params": {
    "script": "() => new Promise(resolve => setTimeout(() => resolve('Page loaded'), 3000))"
  }
}
```

### Step 1.3: Extract email links (returns JSON string)
```mcp
{
  "tool": "playwright_evaluate",
  "params": {
    "script": "() => { const extractLinks = () => { console.log('üîç Extracting email links...'); const allLinks = Array.from(document.querySelectorAll('a[href]')); const platformNav = document.querySelector('[class*=\"preview-toolbar\"]')?.closest('div'); const emailLinks = []; allLinks.forEach((link) => { const href = link.getAttribute('href'); if (!href || href.includes('javascript:') || href.includes('{{') || href.includes('system.')) return; const rect = link.getBoundingClientRect(); const isVisible = rect.width > 0 && rect.height > 0; const isInPlatformNav = platformNav ? platformNav.contains(link) : false; if (isVisible && !isInPlatformNav) { emailLinks.push({ url: href, text: (link.innerText || 'Image Link').trim(), isImage: !!link.querySelector('img') }); } }); const uniqueUrls = [...new Map(emailLinks.map(l => [l.url, l])).values()]; console.log(`‚úÖ Found ${uniqueUrls.length} unique links`); const result = { links: uniqueUrls, totalLinks: emailLinks.length, uniqueCount: uniqueUrls.length, emailLanguage: document.documentElement.lang || 'en', timestamp: new Date().toISOString() }; return JSON.stringify(result, null, 2); }; return extractLinks(); }"
  }
}
```

### Step 1.4: Screenshot of email
```mcp
{
  "tool": "playwright_screenshot",
  "params": {
    "name": "email-links-extracted"
  }
}
```

---

## PHASE 2: Validate All Extracted Links (HTTP Testing)

### Step 2.1: Validate all links using fetch() API
```mcp
{
  "tool": "playwright_evaluate",
  "params": {
    "script": "async () => { console.log('üîç Starting link validation...'); const extractedData = (() => { const allLinks = Array.from(document.querySelectorAll('a[href]')); const platformNav = document.querySelector('[class*=\"preview-toolbar\"]')?.closest('div'); const emailLinks = []; allLinks.forEach((link) => { const href = link.getAttribute('href'); if (!href || href.includes('javascript:') || href.includes('{{') || href.includes('system.')) return; const rect = link.getBoundingClientRect(); const isVisible = rect.width > 0 && rect.height > 0; const isInPlatformNav = platformNav ? platformNav.contains(link) : false; if (isVisible && !isInPlatformNav) { emailLinks.push({ url: href, text: (link.innerText || 'Image Link').trim() }); } }); const uniqueUrls = [...new Map(emailLinks.map(l => [l.url, l])).values()]; return uniqueUrls; })(); console.log(`üìä Validating ${extractedData.length} unique links...`); const validationResults = []; for (let i = 0; i < extractedData.length; i++) { const link = extractedData[i]; const startTime = Date.now(); try { const response = await fetch(link.url, { method: 'HEAD', mode: 'no-cors' }); const duration = Date.now() - startTime; validationResults.push({ index: i + 1, url: link.url, text: link.text, status: response.status || 'CORS-blocked', statusText: response.statusText || 'Cross-origin (use GET)', accessible: response.ok || response.type === 'opaque', duration: duration, error: null }); console.log(`‚úÖ [${i + 1}/${extractedData.length}] ${link.url.substring(0, 50)}... - ${response.status || 'CORS'} (${duration}ms)`); } catch (error) { const duration = Date.now() - startTime; validationResults.push({ index: i + 1, url: link.url, text: link.text, status: 'ERROR', statusText: error.message, accessible: false, duration: duration, error: error.name }); console.log(`‚ùå [${i + 1}/${extractedData.length}] ${link.url.substring(0, 50)}... - ERROR: ${error.message}`); } } const summary = { totalLinks: extractedData.length, validated: validationResults.length, accessible: validationResults.filter(r => r.accessible).length, errors: validationResults.filter(r => r.status === 'ERROR').length, corsBlocked: validationResults.filter(r => r.status === 'CORS-blocked').length, avgDuration: Math.round(validationResults.reduce((sum, r) => sum + r.duration, 0) / validationResults.length) }; console.log(`‚úÖ Validation complete: ${summary.accessible}/${summary.totalLinks} accessible`); const result = { summary: summary, results: validationResults, timestamp: new Date().toISOString() }; return JSON.stringify(result, null, 2); }"
  }
}
```

---

## PHASE 3: Take Final Screenshot

### Step 3.1: Capture final state
```mcp
{
  "tool": "playwright_screenshot",
  "params": {
    "name": "validation-complete-{{asset_id}}"
  }
}
```

---

## WHAT THIS VALIDATES

**‚úÖ What This Version Does:**
1. **Extract all email links** - Visible, non-platform links with deduplication
2. **HTTP validation** - Tests each link using browser fetch() API
3. **Status detection** - Detects accessible vs broken links
4. **Response time** - Measures performance for each link
5. **Error handling** - Catches network errors, timeouts, CORS issues
6. **Complete report** - JSON output with all results

**Output Includes:**
- **Per-link data**: URL, anchor text, status, duration, errors
- **Summary stats**: Total links, accessible count, error count, avg duration
- **Progress logging**: Real-time console output during validation

**‚ö†Ô∏è CORS Limitations:**

Due to browser security (CORS), some cross-origin requests may show as "CORS-blocked":
- **CORS-blocked** usually means the link IS accessible (just blocked by browser security)
- **ERROR** means genuine failure (network error, DNS failure, timeout)
- **Status 200/404/403/500** means we got a real HTTP response

**What's Different From CLI Version:**

The original `integrated_smart_validation.mdc` (CLI version) has additional features:
- ‚úÖ AI-based language detection (GPT analysis)
- ‚úÖ Curl-based validation (bypasses CORS, gets exact status codes)
- ‚úÖ CSV export with recommendations
- ‚úÖ Bash scripts for complex conditional logic
- ‚úÖ Localization checking (e.g., /en/ vs /ja/)

**This Streamlit version:**
- ‚úÖ Works in cloud without bash dependencies
- ‚úÖ Pure browser-based (portable to any platform)
- ‚úÖ Full link validation (all links tested)
- ‚ö†Ô∏è CORS may block some status codes
- ‚ö†Ô∏è No CSV export (display only)
- ‚ö†Ô∏è No AI language detection

**Performance:**
- ~2-5 seconds per link validation
- 10 links ‚âà 20-50 seconds
- 20 links ‚âà 40-100 seconds
- All links tested sequentially
